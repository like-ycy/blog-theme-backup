---
title:      " linux运维面试问题总结 "
date:       2020/06/29 9:21
banner_img: "https://image.my-blog.wang/header/header.jpg"
tags: [ 面试 ]

---

### kube-proxy挂掉的影响

service的访问请求将不会转发到Pod上，用户无法访问

### k8s service涉及到的组件

kube-proxy、pod、Replication Controller

### ingress和service的区别

Service可以看作是一组提供相同服务的Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。Ingress 是全局的，为了代理不同后端 Service 而设置的负载均衡服务。

Service 有三种对外暴露的方法，但是由于每个 Service 都要有一个负载均衡的服务，所以采用 Service 的话，会造成既浪费成本又高的现象。而ingress是一个全局的负载均衡器,然后我只需要通过访问 URL 就可以把请求转发给不同的后端 Service ，从而可以访问到界面，而不是每个 Service 都需要负载均衡。
### k8s设置node节点污点
kubectl taint node [node] key=value[effect]   
     其中[effect] 可取值: [ NoSchedule | PreferNoSchedule | NoExecute ]
      NoSchedule: 一定不能被调度
      PreferNoSchedule: 尽量不要调度
      NoExecute: 不仅不会调度, 还会驱逐Node上已有的Pod

### k8s的pause容器有什么用

pod内的其他容器会共用pause容器的网络栈和存储卷，保证pod内的其他容器的端口不能冲突，彼此都是通过localhost就可以访问，扮演PID1的角色,并在子进程称为"孤儿进程"的时候,通过调用wait()收割这个子进程,这样就不用担心我们的Pod的PID namespace里会堆满僵尸进程了。

### kubernetes中的pause容器主要为每个业务容器提供以下功能：

PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID。

网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围。

IPC命名空间：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信。

UTS命名空间：Pod中的多个容器共享一个主机名；Volumes（共享存储卷）：

Pod中的各个容器可以访问在Pod级别定义的Volumes。

### kafka相比mq的优势

mq的作用：解耦、最终一致性、广播、流浪控制及削峰

优点
 性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。
 时效性：ms级
 可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
 消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;
 有优秀的第三方Kafka Web管理界面Kafka-Manager；
 在日志领域比较成熟，被多家公司和多个开源项目使用；
 功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用

缺点
 Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长
 使用短轮询方式，实时性取决于轮询间隔时间；
 消费失败不支持重试；
 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；

### linux系统执行命令很卡

- top命令查看系统资源使用情况，cpu、内存、负载
- iostat命令查看磁盘IO使用情况

### shell脚本的变量

$0  文件名及路径

$1,$2  参数1，参数2

$#  传递给脚本或函数的参数个数

$$  当前Shell进程ID

$?  判断上个命令的执行成功与否，0为成功。

$@  传递脚本或函数的所有参数

$*  传递脚本或函数的所有参数

### linux cpu 负载概念

这些数据来自于文件/proc/loadavg，内核会负责统计出这些数据。
top和uptime命令显示的内容就来自于这个文件，根据proc的帮助文件可知，这里的值就是单位时间内处于运行状态以及等待磁盘 I/O状态的平均job数量。这里的运行状态和job都是内核的概念，这里进行说明：
1、 对于内核而言，进程和线程都是job
2、 job处于运行状态指job处于内核的运行队列中，正在或等待被CPU调度（用户空间的进程正在运行不代表需要被CPU调度，有可能在等待I/O，也有可能在sleep等等）

### linux硬链接和软链接原理

- 硬链接：在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。一般这种链接就称为硬链接。硬链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据。
- 软链接： 软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接可对文件或目录创建。

软连接和硬链接的特点：

软链接：

- 1.软链接是存放另一个文件的路径的形式存在。
- 2.软链接可以 跨文件系统 ，硬链接不可以。
- 3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。
- 4.软链接可以对目录进行链接。

硬链接：

- 1. 硬链接，以文件副本的形式存在。但不占用实际空间。
- 2. 不允许给目录创建硬链接。
- 3. 硬链接只有在同一个文件系统中才能创建。
- 4. 删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。

### linux进程退出指令

 INT（快速关闭）----是当用户键入<Control-C>时由终端驱动程序发送的信号。这是一个终止当前操作的请求，如果捕获了这个信号，一些简单的程序应该退出，或者允许自给被终止，这也是程序没有捕获到这个信号时的默认处理方法。拥有命令行或者输入模式的那些程序应该停止它们在做的事情，清除状态，并等待用户的再次输入。

  TERM（快速关闭）----是请求彻底终止某项执行操作，它期望接收进程清除自给的状态并退出。

  HUP---- 平滑启动。如果想要更改配置而不需停止并重新启动服务，请使用该命令。在对配置文件作必要的更改后，发出该命令以动态更新服务配置。

  QUIT：从容关闭。


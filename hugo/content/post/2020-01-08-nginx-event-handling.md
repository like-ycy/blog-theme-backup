---
showonlyimage: true
title:      " Nginx对网络事件的处理 "
subtitle:   ""
excerpt: ""
description: ""
date:       2020-01-08
author:     "望翔"
image: "https://image.my-blog.wang/header/header.jpg"
published: true
tags:
    - Nginx

categories: [ Tech ]
URL: "/2020/01/08/nginx-event-handling/"


---

# 网络传输

![](https://image.my-blog.wang/nginx-uages/200108/network-transfer.png)

接下来看上面这张图，比如主机 A 就是一台家里的笔记本电脑，那么主机 B 就是一台服务器，上面跑着 Nginx 服务。从主机 A 发送一个 HTTP 的 GET 请求到主机 B，这样的一个过程中主要经历了哪些事件？通过上图数据流部分可以看出：

**应用层**里发送了一个 GET 请求 -> 到了**传输层**，这一步主要在做一件事，就是浏览器打开了一个端口，在 windows 的任务管理器中可以看到这一点，他会把这个端口记下来以及把 Nginx 打开的端口比如 80 或者 443 也记到传输层 -> 然后在**网络层**会记下我们主机所在的 IP 和目标主机，也就是 Nginx 所在服务器公网 IP -> 到**链路层**以后 -> 经过**以太网** -> 到达家里的路由器（**网络层**），家中的路由器会记录下所在运营商的一些下一段的 IP -> 通过**广域网** -> 跳转到主机 B 所在的机器中 -> 报文会经过**链路层** -> **网络层** -> 到**传输层**，在传输层操作系统就知道是给那个打开了 80 或者 443 的进程，这个进程自然就是 Nginx -> 那么 Nginx 在他的 HTTP 状态处理机里面（**应用层**）就会处理这个请求。

在上述过程中网络报文扮演了一个怎样的角色呢？

# TCP流与报文

![](https://image.my-blog.wang/nginx-uages/200108/tcp-message.png)

数据链路层会在数据的前面 Header 部分和 Footer 部分添加上源 MAC 地址和源目的地址 -> 到了网络层则是 Nginx 的公网地址（目的 IP 地址）和浏览器的公网地址（源 IP 地址）-> 到了 TCP 层（传输层），指定了 Nginx 打开的端口（目的端口）和浏览器打开的端口（源端口）-> 然后应用层就是 HTTP 协议了。

这就是一个报文，也就是说我们发送的 HTTP 协议会被切割成很多小的报文，在网络层会切割叫 MTU，以太网的每个 MTU 是 1500 字节；在 TCP 层（传输层）呢会考虑中间每个环节中最大的一个 MTU 值，这个时候往往每个报文只有几百字节，这个报文大小我们称为叫 MSS ，所以每收到一个 MSS 小于这么大小的一个报文时其实就是一个网络事件。

这个时候，我们来看下 TCP 协议中许多事件是怎样和我们日常调用的一些接口（比如Accept、Read、Write、Close）是怎样关联在一起的？

# TCP 协议与非阻塞接口

![](https://image.my-blog.wang/nginx-uages/200108/tcp-ip.png)

请求建立 TCP 连接事件实际上是发送了一个 TCP 报文，通过上面第二部分讲解的那样的一个流程到达了 Nginx，对应的是读事件。因为对于 Nginx 来说，我读取到了一个报文，所以就是 Accept 建立链接事件。

如果是 TCP 连接可读事件，就是发送了一个消息，对于 Nginx 也是一个读事件，就是 Read 读消息。

如果是对端（也就是浏览器）主动地关掉了，相当于 windows 操作系统会去发送一个要求关闭链接的一个事件，对于 Nginx 来说还是一个读事件，因为他只是去读取一个报文。

那什么是写事件呢？当我们的浏览器需要向浏览器发送响应的时候，需要把消息写到操作系统中，要求操作系统发送到网络中，这就是一个写事件。

像这样的一些网络读写事件，通常在 Nginx 中或者任何一个异步事件的处理框架中，他会有个东西叫事件收集、分发器。会定义每类事件处理的消费者，也就是说事件是一个生产者，是通过网络中自动的生产到我们的 Nginx 中的，我们要对每种事件建立一个消费者。比如连接建立事件消费者，就是对 Accept 调用，HTTP 模块就会去建立一个新的连接。还有很多读消息或者写消息，在 HTTP 状态机中不同的时间段会调用不同的方法也就是每个消费者处理。

以上就是一个事件分发、消费器，包括 AIO 像异步读写磁盘事件，还有定时器事件，比如是否超时（worker_shutdown_timeout）。

# Nginx 网络事件实例

上面介绍了网络报文的发送以及对应的 Nginx 中的网络事件，比如 Accept 建立一条新连接其实是收到一条读事件，接下来我们通过抓包来分析建立三次握手时时怎么样让 Nginx 收到读事件，使用的抓包工具是 Wireshark。

<img src="https://image.my-blog.wang/nginx-uages/200108/wireshark.png"  />

首先我们安装 Wireshark 软件，并对 Nginx 所在 IP 和端口进行抓包，然后访问页面，在 TCP 层主要说两件事情：

- 浏览器首先会打开这个页面，本地打开了一个 1875 端口，而 Nginx 启动的是 8080 端口。
- TCP 层主要做的是进程与进程之间通讯这件事。

![](https://image.my-blog.wang/nginx-uages/200108/tcp-header.png)



IP 层主要解决机器与机器之间怎样互相找到的问题。

![](https://image.my-blog.wang/nginx-uages/200108/ip-header.png)

三次握手也就是 windows 先向 Nginx 发送了一次 [SYN]，那么相反的 Nginx 所在的服务器也会向 windows 发送一个 [SYN]，这个时候 Nginx 是没有感知到的，因为这个连接还是处于半打开的状态。直到这台 windows 服务器再次发送 [ACK] 到 Nginx 所在的服务器之上时，Nginx 所在的操作系统才会去通知 Nginx 我们收到了一个读事件，这个读事件对应是建立一个新连接，所以此时 Nginx 应该调用 Accept 方法去建立一个新的连接。

以上我们通过 Wireshark 抓包演示了正常的三次握手是怎么样引发一个读事件来使得 Nginx 去处理这样一个读事件来建立新的连接的。